bool alt_is_down()
{
if(key_down(KEY_LMENU) or key_down(KEY_RMENU))
{
return true;
}
return false;
}
bool control_is_down()
{
if(key_down(KEY_LCONTROL) or key_down(KEY_RCONTROL))
{
return true;
}
return false;
}
bool shift_is_down()
{
if(key_down(KEY_LSHIFT) or key_down(KEY_RSHIFT))
{
return true;
}
return false;
}
bool validate_event_selection(int autoEventList, int manualEventList)
{
    bool hasPositiveAuto = false;
    bool hasNegativeAuto = false;
    bool hasPositiveManual = false;
    bool hasNegativeManual = false;
    string[] positiveAutoEvents = {"bonus_cookies", "increase_cookyspeed", "gain_coins", "gain_autocooky", "gain_manulcooky"};
    string[] negativeAutoEvents = {"fire_spark", "decrease_cookyspeed", "lose_coins", "lose_autocooky", "lose_manulcooky"};
    string[] positiveManualEvents = {"bonus_cookies", "increase_cookyspeed", "gain_coins", "gain_autocooky", "gain_manulcooky"};
    string[] negativeManualEvents = {"fire_spark", "decrease_cookyspeed", "lose_coins", "lose_autocooky", "lose_manulcooky"};
    for (uint i = 0; i < autoBakingEvents.length(); i++)
{
        if (form.is_list_item_checked(autoEventList, i))
{
            if (positiveAutoEvents.find(autoBakingEvents[i]) > -1) hasPositiveAuto = true;
            if (negativeAutoEvents.find(autoBakingEvents[i]) > -1) hasNegativeAuto = true;
        }
    }
    for (uint i = 0; i < manualBakingEvents.length(); i++)
{
        if (form.is_list_item_checked(manualEventList, i))
{
            if (positiveManualEvents.find(manualBakingEvents[i]) > -1) hasPositiveManual = true;
            if (negativeManualEvents.find(manualBakingEvents[i]) > -1) hasNegativeManual = true;
        }
    }
    return (hasPositiveAuto && hasNegativeAuto && hasPositiveManual && hasNegativeManual);
}

double min(double a, double b)
{
return (a < b) ? a : b;
}
double max(double a, double b)
{
return (a > b) ? a : b;
}
double buy_item(double item, double base_cost, double costMultiplier)
{
return 1+(item*0.1)*base_cost*costMultiplier;
}
double calc_automation_cost(double count, double baseCost, double multiplier)
{
    double total = 0;
    double cost = baseCost;
    for (int i = 0; i < count; i++)
    {
        total += cost;
        cost *= multiplier;
    }
    return total;
}
double calc_slot_cost(double count)
{
    double total = 0;
    double cost = slotBaseCost;
    for (int i = 0; i < count; i++)
    {
        total += cost;
        cost *= slotMultiplier;
    }
    return total;
}
double get_save_rank(string saveFile)
{
    if (!file_exists(saveFile))
    {
        return -1;
    }
    savedata tempSave(saveFile, "rQP8u9I5iWYwcmwPkJ5EzU3ri4r6IQFP77dvgYedgyGQPxzHEi1eKGdBEENLRbYEWBr3hAmmQLgyevhYJJ7Q3sUQt5n6BKjzYVZMWQb2LyYx");
    tempSave.load();
    if (tempSave.d.exists("rank"))
    {
        return tempSave.read_double("rank");
    }
    return 0;
}

int string_to_int(string str)
{
    int result = 0;
    bool isNegative = false;
    if (str.length() == 0)
        return 0;
    if (str.substr(0, 1) == "-")
    {
        isNegative = true;
        str = str.substr(1);
    }
    for (uint i = 0; i < str.length(); i++)
    {
        string digitStr = str.substr(i, 1);
        int digit = 0;
        if (digitStr == "0") digit = 0;
        else if (digitStr == "1") digit = 1;
        else if (digitStr == "2") digit = 2;
        else if (digitStr == "3") digit = 3;
        else if (digitStr == "4") digit = 4;
        else if (digitStr == "5") digit = 5;
        else if (digitStr == "6") digit = 6;
        else if (digitStr == "7") digit = 7;
        else if (digitStr == "8") digit = 8;
        else if (digitStr == "9") digit = 9;
        else return 0;
        result = result * 10 + digit;
    }
    return isNegative ? -result : result;
}

string format_number(double num)
{
    if (num <= 999999 && num >= -999999)
        return round(num, 0);
    double absNum = abs(num);
    string[] suffixes = {" Million", " Billion", " Trillion", " Quadrillion", " Quintillion", " Sextillion", " Septillion", " Octillion", " Nonillion", " Decillion"};
    double divisor = 1e6;
    for (uint i = 0; i < suffixes.length(); i++)
    {
        double shortened = num / divisor;
        if (abs(shortened) < 1000 || i == suffixes.length() - 1)
        {
            return round(shortened, 2) + suffixes[i];
        }
        divisor *= 1000;
    }
    return round(num, 0);
}

string convert_to_currency(double number, string currency_symbol)
{
if (number < 0) return "";
uint dollars = number / 100;
uint cents = number % 100;
string cents_str = "" + cents;
if (string_len (cents_str) == 1) cents_str = "0" + cents_str;
return currency_symbol + dollars + "." + cents_str;
}
string random_string(string[] array)
{
string retval=array[random(0,array.length()-1)];
return retval;
}

void set_save_slot(int slot)
{
    currentSaveSlot = DIRECTORY_APPDATA + "tsatria03/CookyCraze/saves/game" + string(slot) + ".crz";
    sd = savedata(currentSaveSlot, "rQP8u9I5iWYwcmwPkJ5EzU3ri4r6IQFP77dvgYedgyGQPxzHEi1eKGdBEENLRbYEWBr3hAmmQLgyevhYJJ7Q3sUQt5n6BKjzYVZMWQb2LyYx");
}
void add_baking_slots()
{
    setupmenu(false);
    m.add_item("Add 1 slot for "   + format_number(calc_slot_cost(1))   + " coins", "add_slot");
    m.add_item("Add 5 slots for "   + format_number(calc_slot_cost(5))   + " coins", "add_slot2");
    m.add_item("Add 10 slots for "  + format_number(calc_slot_cost(10))  + " coins", "add_slot3");
    m.add_item("Add 25 slots for "  + format_number(calc_slot_cost(25))  + " coins", "add_slot4");
    m.add_item("Add 50 slots for "  + format_number(calc_slot_cost(50))  + " coins", "add_slot5");
    m.add_item("Add 100 slots for " + format_number(calc_slot_cost(100)) + " coins", "add_slot6");
    m.add_item("Add 250 slots for " + format_number(calc_slot_cost(250)) + " coins", "add_slot7");
    m.add_item("Add 500 slots for " + format_number(calc_slot_cost(500)) + " coins", "add_slot8");
    m.add_item("Back", "back");
    m.intro_text = "Produced slots menu.";
m.set_focused_item(last_menu_index, false);
        int mres2 = m.run();
last_menu_index = mres2;
        string slotprod = m.get_selected_item_id();
        if (mres2 == -1 || m.get_selected_item_id() == "back")
        {
last_menu_index=0;
            manage_baking_slots();
        }
        int count = 0;
        if (slotprod == "add_slot")   count = 1;
        if (slotprod == "add_slot2")  count = 5;
        if (slotprod == "add_slot3")  count = 10;
        if (slotprod == "add_slot4")  count = 25;
        if (slotprod == "add_slot5")  count = 50;
        if (slotprod == "add_slot6")  count = 100;
        if (slotprod == "add_slot7")  count = 250;
        if (slotprod == "add_slot8")  count = 500;
        if (count > 0)
        {
            double cost = calc_slot_cost(count);
            if (coins >= cost)
            {
                coins -= cost;
                for (int i = 0; i < count; i++)
                {
                    baking_slots.insert_last(true);
                    autobakeSlotEnabled.insert_last(false);
                    slotBaseCost *= slotMultiplier;
                }
                pool.destroy_sound(alertslot);
                alertslot = pool.play_stationary("prodslot.ogg", false);
int produced = baking_slots.length();
int automated = autobakeSlots;
int nonauto = produced - automated;
speak("Added " + string(count) + " slot" + (count == 1 ? "" : "s") + ". You now have " + string(produced) + " produced slot" + (produced == 1 ? "" : "s") + ".");
last_menu_index = mres2;
            add_baking_slots();
            }
            else
            {
                alertslot = pool.play_stationary("error.ogg", false);
                dlg("Error! You don't have enough coins to add " + string(count) + " new slot" + (count == 1 ? "" : "s") + "!");
                pool.destroy_sound(alertslot);
last_menu_index = mres2;
add_baking_slots();
}
}
}
void manage_baking_slots()
{
setupmenu(false);
m.add_item("Automated slots", "automated");
m.add_item("Non-automated slots", "nonauto");
        m.add_item("Produced slots", "slp");
m.add_item("Back", "back");
int produced = baking_slots.length();
int automated = autobakeSlots;
int nonauto = produced - automated;
m.intro_text = "Slot manager menu. You have " + string(produced) + " produced slot" + (produced == 1 ? "" : "s") + ", " + string(automated) + " automated slot" + (automated == 1 ? "" : "s") + ", and " + string(nonauto) + " non-automated slot" + (nonauto == 1 ? "" : "s") + ".";
int mres = m.run();
if (mres == -1 || m.get_selected_item_id() == "back") clickergame();
string selected = m.get_selected_item_id();
if (selected == "slp")
{       
add_baking_slots();
}
if (selected == "automated" || selected == "nonauto")
{
    setupmenu(false);
    int nonAutoCount = 0;
    for (uint i = 0; i < autobakeSlotEnabled.length(); i++)
    {
        bool isAuto = autobakeSlotEnabled[i];
        if ((selected == "automated" && isAuto) || (selected == "nonauto" && !isAuto))
        {
            string autoStatus = isAuto ? "automated" : "unautomated";
            string cookiesInfo = "";
            if (slotDistribution && autobakeSlots > 0)
            {
                double cookiesPerSlot = autocooky / autobakeSlots;
                cookiesInfo = " with " + format_number(cookiesPerSlot) + " cookies per slot";
            }
            m.add_item("Slot " + string(i + 1) + ": " + autoStatus + cookiesInfo + ".", "slot" + string(i));
            if (!isAuto) nonAutoCount++;
        }
    }
    if (selected == "nonauto" && nonAutoCount > 0)
    {
        double totalCost = calc_automation_cost(nonAutoCount, automationBaseCost, automationMultiplier);
        m.add_item("Automate all unautomated slots for " + format_number(totalCost) + " coins", "automate_all");
    }
    m.add_item("Back", "back");
    m.intro_text = (selected == "automated" ? "Automated slots menu." : "Non-automated slots menu.");
    int slotres = m.run();
    if (slotres == -1 || m.get_selected_item_id() == "back") manage_baking_slots();
    string s = m.get_selected_item_id();
    if (s == "automate_all")
    {
        double totalCost = calc_automation_cost(nonAutoCount, automationBaseCost, automationMultiplier);
        if (coins >= totalCost)
        {
            coins -= totalCost;
            for (uint i = 0; i < autobakeSlotEnabled.length(); i++)
            {
                if (!autobakeSlotEnabled[i])
                {
                    autobakeSlotEnabled[i] = true;
                    autobakeSlots++;
                    automationBaseCost *= automationMultiplier;
                }
            }
            pool.destroy_sound(alertslot);
            alertslot = pool.play_stationary("autslot.ogg", false);
            speak("Successfully automated " + string(nonAutoCount) + " unautomated slot" + (nonAutoCount == 1 ? "" : "s") + " for " + format_number(totalCost) + " coins.");
        }
        else
        {
            alertslot = pool.play_stationary("error.ogg", false);
            dlg("Error! You don't have enough coins to automate all slots!");
            pool.destroy_sound(alertslot);
        }
        manage_baking_slots();
    }
    if (s.substr(0, 4) == "slot")
    {
        int index = string_to_int(s.substr(4));
        if (index >= 0 && index < baking_slots.length())
        {
            setupmenu(false);
            if (!autobakeSlotEnabled[index])
                m.add_item("Automate this slot for " + format_number(automationBaseCost) + " coins", "automate");
            m.add_item("Preview slot sound", "preview");
            m.add_item("Back", "back");
            m.intro_text = "Slot automation menu.";
            int subres = m.run();
            if (subres == -1 || m.get_selected_item_id() == "back") manage_baking_slots();
            if (m.get_selected_item_id() == "preview")
            {
                pool.play_stationary("autobake.ogg", false);
                manage_baking_slots();
            }
            else if (m.get_selected_item_id() == "automate")
            {
                double singleCost = calc_automation_cost(1, automationBaseCost, automationMultiplier);
                if (coins >= singleCost)
                {
                    coins -= singleCost;
                    automationBaseCost *= automationMultiplier;
                    autobakeSlotEnabled[index] = true;
                    autobakeSlots++;
                    pool.destroy_sound(alertslot);
                    alertslot = pool.play_stationary("autslot.ogg", false);
                    speak("Slot " + string(index + 1) + " is now automated.");
                }
                else
                {
                    alertslot = pool.play_stationary("error.ogg", false);
                    dlg("Error! You don't have enough coins to automate this slot!");
                    pool.destroy_sound(alertslot);
                }
                manage_baking_slots();
            }
        }
    }
}
}

void wait_async(int milliseconds)
{
    timer WaitTimer;
    WaitTimer.restart();    
    while (WaitTimer.elapsed < milliseconds)
    {
        wait(5);
        form.monitor();
int betChoice, betInput, symbolChoices;
if(form.get_current_focus()!=betChoice and form.get_current_focus()!=betInput and form.get_current_focus()!=symbolChoices) slots_game_input();
        key_code[] keys = keys_pressed();
        for (uint i = 0; i < keys.length(); i++)
        {
            key_code key = keys[i];
        }
    }
}
